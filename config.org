#+TITLE: My emacs config
#+AUTHOR: Justin Smith
#+TOC: true
#+STARTUP: indent
#+PROPERTY: header-args :tangle yes

* Introduction

This is my [[https://www.gnu.org/software/emacs/][GNU Emacs]] configuration.

This configuration is oriented around the following:

 - Vim-style keybindings via evil
 - One menu to access most features, like spacemacs
 - An attempt to look OK-ish
 - A focus on ~org-mode~, "curly-brace" languages (C/C++, Go, PHP,
   some JavaScript), and webdev

I am not using spacemacs (which offers all of the above) because I
found myself turning on features and then later wondering why my emacs
was running so slow.  That's not so much spacemacs' fault, but since
it's not my code, it gets tricky to suss out where the problem lies.
I am not claiming my code is better than spacemacs; actually it's
probably the reverse.

This configuration is opinionated; it assumes you are heavily sold
on vim keybindings and moreover that you... ahem... agree with me,
I suppose.  In particular, while I like all the packages here, I
may indulge in some... rants... about functionality I find... odd.

(After all, this is a realm of thought where the very choice of
typographical whitespace is fraught with [[https://www.youtube.com/watch?v=SsoOG6ZeyUI][religious significance]]; text
editors are going to be naturally pretty scary in that regard ^_^)

* Initialization
** Variables

#+begin_src emacs-lisp
(defvar jws/emacs-backup-dir (expand-file-name (concat user-emacs-directory ".cache/backups")))
(defvar jws/emacs-desktop-dir (expand-file-name (concat user-emacs-directory ".cache/desktop")))
(defvar jws/emacs-library-dir (expand-file-name (concat user-emacs-directory "lisp")))
(defvar jws/emacs-site-library-dir (expand-file-name (concat user-emacs-directory "site-lisp")))

(defvar jws/site-file (expand-file-name (concat user-emacs-directory "site-init.el")))
(defvar jws/custom-file (expand-file-name (concat user-emacs-directory "custom.el")))

(defvar jws/package-refreshed-already nil)
#+end_src

** Set up package.el

This must be done before we do anything else.

First of all, we ensure ~package~ is loaded, and use MELPA as package
server.

#+begin_src emacs-lisp
  (require 'package)
  (add-to-list 'package-archives
               '("melpa" . "http://melpa.milkbox.net/packages/") t)
#+end_src

Next, I *would* initialize ~package~ with

#+begin_src emacs-lisp :tangle no
  (package-initialize)
#+end_src

but Emacs insists on sticking it on the first line of the first
init file it reads.  *No.  Matter.  What.*  In fact I find that a
lot of my gripes with Emacs is that out-of-the-box it behaves
[[https://en.wikipedia.org/wiki/In_loco_parentis][in loco parentis]] and I prefer the Unixy "I should be able to
~rm -rf /~ if I want to" mindset.

Then, we define some helper functions to work with ~package~.

#+begin_src emacs-lisp
(defun jws/is-refresh-needed (refresh-interval)
  "Determine whether a package refresh is needed -- every REFRESH-INTERVAL days"
  (let* ((now (float-time (current-time)))
         (package-archive-file "~/.emacs.d/elpa/archives/melpa/archive-contents")
         (then (float-time (nth 5 (file-attributes package-archive-file))))
         (refresh-interval-secs (* 24 60 60 refresh-interval)))
    (> (- now then)
       refresh-interval-secs)))

(defun jws/package-refresh-once-a-session ()
  "Refresh package list once a session, if needed"
  (if (not jws/package-refreshed-already)
      (progn
        (package-refresh-contents)
        (setq jws/package-refreshed-already t))))

(defun jws/package-install (pkg)
  "Install package PKG if it is not already installed"
  (unless (package-installed-p pkg)
    (jws/package-refresh-once-a-session)
    (package-install pkg)))
#+end_src

And, finally, we see if a package refresh is needed, and do it if
necessary.

#+begin_src emacs-lisp
;; If it's been seven days since we've refreshed packages, force a refresh
;; Otherwise, don't bother
(setq jws/package-refreshed-already (not (jws/is-refresh-needed 7)))

;; Perform the package refresh, if needed.
;(jws/package-refresh-once-a-session)
#+end_src

** Set up use-package

[[https://github.com/jwiegley/use-package][use-package]] is an invaluable library that allows one to isolate
different libraries being loaded in one's ~.emacs~ blob and load them
efficiently.  The rest of the config relies heavily upon ~use-package~,
so it is loaded very early as well.

Everywhere else, stuff is automatically installed by ~use-package~
where possible.  However, you run into a bit of the good ol'
[[https://en.wikipedia.org/wiki/Chicken_or_the_egg][chicken-and-egg dilemma]] when installing ~use-package~ itself, so we
install it using the functions we defined earlier:

#+begin_src emacs-lisp
  (jws/package-install 'use-package)
#+end_src

and load it manually:

#+begin_src emacs-lisp
  (eval-when-compile
    (require 'use-package))
#+end_src

** Load unpackaged libraries

Libraries included with this config, but not in MELPA, are under
~lisp/~:

#+begin_src emacs-lisp
  (if (file-exists-p jws/emacs-library-dir)
      (let ((default-directory jws/emacs-library-dir))
        (add-to-list 'load-path default-directory)
        (normal-top-level-add-subdirs-to-load-path)))
#+end_src

* Preferences
** Backups

I really dislike how Emacs handles backups and do some pretty
substantial changes to same.

First off, let's create the backup directory:

#+begin_src emacs-lisp
  (if (not (file-exists-p jws/emacs-backup-dir))
      (make-directory jws/emacs-backup-dir t))
#+end_src

And have Emacs use it:

#+begin_src emacs-lisp
  (setq backup-directory-alist `(("." . ,jws/emacs-backup-dir)))
#+end_src

And finally change a bunch more settings:

#+begin_src emacs-lisp
  ;; Backup by copying files
  (setq backup-by-copying t)

  ;; Prune old backups
  (setq delete-old-versions t)

  ;; Control how many old backups are kept
  (setq kept-old-versions 6)
  (setq kept-new-versions 2)

  ;; Always number the backups
  (setq version-control t)

  ;; Make backup files, even if the file's in version control
  (setq vc-make-backup-files t)
#+end_src

Disable auto-save; otherwise IIRC Emacs prompts you annoyingly
to save them at some inconvenient point.  I generally remember
to save my files on my own and do not need this.

#+begin_src emacs-lisp
  (setq auto-save-default nil)
#+end_src

** Usability

Here are some settings to make Emacs more usable in general.

A warning:  I am disabling a number of "safety measures" that Emacs
enables.  Some are silly and the equivalent of [[https://en.wikipedia.org/wiki/Office_Assistant][Clippy]] getting in your
way in Office 2000.  Some are pretty sensible; I will note those.

Sometimes Emacs wants a ~y~ or ~n~ for yes/no questions, sometimes it
requires a ~yes~ or ~no~.  Make everything ~y~ / ~n~.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Enable some disabled functions that confuse some new (l)users:

#+begin_src emacs-lisp
  (put 'narrow-to-region 'disabled nil) ;; C-x n n
  (put 'narrow-to-defun 'disabled nil) ;; C-x n d
  (put 'dired-find-alternate-file 'disabled nil)
#+end_src

Set all theme files as "safe" and thus do not prompt when loading
them.  This is a legit concern.  I only install the ~doom-themes~
and I trust them, but still there's nothing stopping the owner from,
say, selling to a malevolent person who sneaks elisp to mine BTC
into the themes.

#+begin_src emacs-lisp
  (setq custom-safe-themes t)
#+end_src

Always put point in help windows (info, describe-variable...) so
that one does not have to hunt the buffer down to close it.

#+begin_src emacs-lisp
  (setq help-window-select t)
#+end_src

* Appearance
I like a very minimal Emacs (and Vim) window since both were
made to be driven from the keyboard.

#+begin_src emacs-lisp
  (if (functionp 'tool-bar-mode) (tool-bar-mode -1))
  (if (functionp 'horizontal-scroll-bar-mode) (horizontal-scroll-bar-mode -1))
  (if (functionp 'scroll-bar-mode) (scroll-bar-mode -1))
  (if (functionp 'menu-bar-mode) (menu-bar-mode -1))
#+end_src

This disables the buffer that has all the GNU Project boilerplate
and how to use Info and blahblahblah just show me an emacs window

(We'll put in a more useful startup buffer later.)

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

I have this labeled "Vim-style line-by-line scrolling" and
I wish I knew exactly what it did.  I do recall not liking how
Emacs scrolled out-of-the-box.

#+begin_src emacs-lisp
  (setq scroll-step 1)
  (setq scroll-conservatively 10000)
#+end_src

Turn the "system bell" off.  The last time this was relevant to
computers, I was not alive yet and bell bottoms were en vogue; in 2019
it shows as an annoying full-screen flash on most computers.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Icons

[[https://github.com/domtronn/all-the-icons.el][all-the-icons]] pulls in several icon fonts which can be used by other
packages (e.g. ~doom-modeline~).

#+begin_src emacs-lisp
  (use-package all-the-icons :ensure t)
#+end_src

Installation of the fonts must be done (once per machine) via the
command

#+begin_src emacs-lisp :tangle no
  (all-the-icons-install-fonts)
#+end_src

** Themes

Install doom-themes, which are a nice set of themes that work with a
lot of libraries and look nice:

#+begin_src emacs-lisp
  (use-package doom-themes :ensure t)
#+end_src

** Modeline

[[https://github.com/seagle0128/doom-modeline][doom-modeline]] is an attractive, featureful, and performant modeline
replacement.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :hook (after-init . doom-modeline-mode)
    :config
    (column-number-mode)
    (setq doom-modeline-buffer-file-name-style 'buffer-name
          doom-modeline-icon t
          doom-modeline-major-mode-icon t
          doom-modeline-buffer-state-icon t))
#+end_src

[[https://github.com/tarsius/minions][minions]] hides all those pesky minor-modes behind a clickable menu.
Unlike the more popular [[https://github.com/myrjola/diminish.el][diminish]], ~minions~ just hides everything,
which is fine by me.

#+begin_src emacs-lisp
  (use-package minions
    :ensure t
    :config
    (minions-mode 1))
#+end_src

Sometimes you just gotta have fun, nyan~ ^_^

(In all seriousness, ~nyan-mode~ is a nice document position
indicator.)

#+begin_src emacs-lisp
  (use-package nyan-mode
    :ensure t
    :config
    (nyan-mode)
    (setq nyan-bar-length 20))
#+end_src

* Functionality
** Vim compatibility

This is the raison d'Ãªtre of the whole guide.

#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init (setq evil-want-keybinding nil)
    :config
    (evil-mode t))
#+end_src

Some other ~evil~ related packages:

 - ~evil-surround~ is a port of [[https://github.com/tpope/vim-surround][surround.vim]]
 - ~evil-collection~ tries to bring vi/evil keybindings to other Emacs modes

#+begin_src emacs-lisp
  (use-package evil-surround
    :after evil
    :ensure t
    :config
    (global-evil-surround-mode 1))

  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (setq evil-collection-mode-list '(dired eshell eww git-timemachine ibuffer image image+))
    (evil-collection-init))

#+end_src
** Menu completion

i.e. speeding up menu traversal.

I like [[https://github.com/abo-abo/swiper][counsel and ivy]] to do this for me.  ~ivy~ is the backend
library that provides the menu structure.

#+begin_src emacs-lisp
  (use-package ivy
    :ensure t
    :commands (ivy-switch-buffer)
    :config
    (setq ivy-use-virtual-buffers t
          ivy-count-format "(%d/%d)"
          ivy-magic-tilde nil)

    ;; Makes RET in counsel-find-file actually work correctly
    ;; and not dump you in dired for whatever reason
    (define-key ivy-minibuffer-map (kbd "<return>") 'ivy-alt-done)

    ;; Move ivy-restrict-to-matches from S-SPC to C-RET
    ;; I do not like emacs bindings using Super; that's for my
    ;; window manager only!
    (define-key ivy-minibuffer-map (kbd "S-SPC") nil)
    (define-key ivy-minibuffer-map (kbd "C-<return>") 'ivy-restrict-to-matches))
#+end_src

~counsel~ provides some useful functions built on top of ~ivy~.

#+begin_src emacs-lisp
  (use-package counsel
    :ensure t
    :after ivy
    :commands (counsel-bookmark
               counsel-describe-face
               counsel-describe-function
               counsel-describe-variable
               counsel-find-file
               counsel-grep-or-swiper
               counsel-M-x
               counsel-recentf
               counsel-semantic-or-imenu)
    :config
    (setq counsel-find-file-at-point t))
#+end_src

[[https://github.com/Yevgnen/ivy-rich][ivy-rich-mode]] makes some of the more frequently used ~counsel~
commands function slightly nicer.

#+begin_src emacs-lisp
  (use-package ivy-rich
    :ensure t
    :after counsel
    :config (ivy-rich-mode 1))
#+end_src

[[https://github.com/lewang/flx][flx]] provides a fuzzy search algorithm, which is picked up
automatically by ~ivy~ and ~counsel~.

#+begin_src emacs-lisp
  (use-package flx :ensure t :after ivy)
#+end_src

[[https://github.com/nonsequitur/smex][smex]] provides an even more efficient ~M-x~ command, which is picked up
automatically by ~counsel-M-x~.

#+begin_src emacs-lisp
  (use-package smex :ensure t :after counsel)
#+end_src

~swiper~ is developed by the same guy that did ~ivy~ and ~counsel~,
and in the same GitHub repository; it provides a text search menu
using ~ivy~.

#+begin_src emacs-lisp
  (use-package swiper
    :ensure t
    :commands (swiper)
    :after ivy)
#+end_src

** Text completion

** Menu creation

The [[https://github.com/abo-abo/hydra][hydra]] package (by the same mad genius responsible for ~ivy~ et al)
allows for easy-ish interactive menus.

#+begin_src emacs-lisp
  (use-package hydra :ensure t)
#+end_src

Note that ~hydra~ uses a "color" system where keybinds are assigned
a color, which determines their behavior.  For our purposes:

 - red (the default) runs the command and jumps right back into the
   hydra
 - blue runs the command and exits the hydra

I use blue very extensively since most commands are going to be
fire-and-forget.

*** Emacs menu
#+begin_src emacs-lisp
  (defhydra jws/hydra-emacs (:color blue)
    "Buffer menu"
    ("q" save-buffers-kill-terminal "Quit emacs")
    ("i" package-install "Install package")
    ("k" server-start "Start server"))
#+end_src

*** Buffer menu
#+begin_src emacs-lisp
  (defhydra jws/hydra-buffer (:color blue)
    "Buffer menu"
    ("b" ivy-switch-buffer "Switch buffer")
    ("i" ibuffer "Buffer list")
    ("k" kill-this-buffer "Kill buffer")
    ("s" save-buffer "Save buffer")
    ("S" write-file "Save buffer elsewhere")
    ("u" bury-buffer "Bury buffer"))
#+end_src

*** File menu
#+begin_src emacs-lisp
  (defhydra jws/hydra-files (:color blue)
    "File menu"
    ("a" ff-find-other-file "Find file")
    ("f" counsel-find-file "Find file")
    ("r" counsel-recentf "Find recent file")
    ("u" counsel-bookmark "Find bookmark"))
#+end_src

*** Help menu

~woman~ is an Emacs Lisp implementation of the [[https://en.wikipedia.org/wiki/Nroff][nroff]] code that
formats ~man~ pages.  This allows ~woman~ to work on Windows;
but it does make it slower.  At some point it may be a good
idea to use ~man~ when available; also find some way to
present these via ~ivy~.

#+begin_src emacs-lisp
  (defhydra jws/hydra-help (:color blue)
    "Help menu"
    ("i" info "Info")
    ("f" counsel-describe-function "Describe function")
    ("m" woman "Man pages")
    ("v" counsel-describe-variable "Describe variable"))
#+end_src

*** Master menu
I continue to be amazed that Emacs doesn't have this...

#+begin_src emacs-lisp
  (defun jws/switch-to-previous-buffer ()
    "Switches to the previous buffer."
    (interactive)
    (switch-to-buffer (other-buffer (current-buffer))))
#+end_src

#+begin_src emacs-lisp
  (defhydra jws/hydra-master (global-map "M-j" :color blue)
    "Master menu"
    ("SPC" counsel-M-x "Command list")
    ("<tab>" jws/switch-to-previous-buffer "Switch buffer")
    ("b" jws/hydra-buffer/body "Buffers")
    ("e" jws/hydra-emacs/body "Emacs")
    ("f" jws/hydra-files/body "Files")
    ("h" jws/hydra-help/body "Help"))

  (define-key evil-normal-state-map (kbd "SPC") 'jws/hydra-master/body)
#+end_src

* Extras
** Package management

I like Paradox for graphical package installation.

#+begin_src emacs-lisp
  (use-package paradox
    :ensure t
    :commands (paradox-list-packages paradox-upgrade-packages)
    :config
    (setq paradox-github-token t) ;; disable GitHub integration
    (with-eval-after-load 'evil
      (add-to-list 'evil-emacs-state-modes 'paradox-menu-mode))
    (define-key paradox-menu-mode-map (kbd "j") 'next-line)
    (define-key paradox-menu-mode-map (kbd "k") 'previous-line))
#+end_src

** File management
* Editing

Supposedly some people use Emacs to edit files.  The horror!

Some odds and ends first.

This will automatically timestamp any file with ~Time-stamp: <>~
towards its top on save.  This is less necessary in the era of Git
everywhere, but hey.

#+begin_src emacs-lisp
  (add-hook 'before-save-hook 'time-stamp)
#+end_src

If the file you're editing has a shebang (~#!~) at its top, Emacs
can make it executable, which we will do after saving.

#+begin_src emacs-lisp
  (add-hook 'after-save-hook
            'executable-make-buffer-file-executable-if-script-p)
#+end_src

I want Emacs to remember where I was in a file when I had it open
last; ~save-place-mode~ accomplishes that.

#+begin_src emacs-lisp
  (use-package saveplace
    :init (save-place-mode))
#+end_src

I like highlighting the matching paren.  It's good for all languages,
but I would be reduced to a gibbering mess without this enabled for
Lisp.

#+begin_src emacs-lisp
  (use-package paren
    :init (show-paren-mode))
#+end_src

~focus~ is a neat package that only highlights the specific region of
code that your cursor is on.

#+begin_src emacs-lisp
  (use-package focus :ensure t :commands (focus-mode))
#+end_src
** Character encoding

I want to force UTF-8 everywhere, even on Windows; ultimately most of
my code is compiled/run on Unixes and Windows settings actively get in
the way of that.  Some resources on the matter:

 - [[https://stackoverflow.com/a/2903256]]
 - [[https://rufflewind.com/2014-07-20/pasting-unicode-in-emacs-on-windows]]

The latter notes that you must be careful on Windows as to which
settings you enable.

#+begin_src emacs-lisp
  (setq utf-translate-cjk-mode nil ; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
        locale-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-keyboard-coding-system 'utf-8-mac) ; For old Carbon emacs on OS X only
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system
    (if (eq system-type 'windows-nt) 'utf-16-le 'utf-8))
  (prefer-coding-system 'utf-8)
#+end_src

** org-mode

Hoo boy.

I use the ~org~ that comes with Emacs.

#+begin_src emacs-lisp
  (use-package org
    :commands (org-agenda org-capture org-export-dispatch org-store-link)
    :ensure t
    :mode (("\\.org\\'" . org-mode))
    :config
    (add-to-list 'org-modules 'org-habit)
    (setq org-src-fontify-natively t))
#+end_src

* Site-specific code

As much as I'd like to have a one-size-fits-all config, I've found
that impossible.  The easiest example would be fonts; on some machines
I might not have access to my preferred fonts, on others I might want
a bigger font size or whatever.

Furthermore, I might need a very specific mode, or set up mappings
to certain file extensions.

If I need to run specific (unpackaged) libraries, I keep them under
~site-lisp/~ in this directory:

#+begin_src emacs-lisp
  (if (file-exists-p jws/emacs-site-library-dir)
      (let ((default-directory jws/emacs-site-library-dir))
        (add-to-list 'load-path default-directory)
        (normal-top-level-add-subdirs-to-load-path)))
#+end_src

My site-specific init file is kept in the same directory as this
file, at ~site-init.el~.  I may look into making an org file out of
this as well.

#+begin_src emacs-lisp
  (load jws/site-file t)
#+end_src

Finally, this is where emacs' ~Customize~ interface drops its stuff.
I would disable ~Customize~ entirely, but there are some packages that
document their ~Customize~ variables and do not really give the actual
variable names to customize manually.

#+begin_src emacs-lisp
  (load jws/custom-file t)
#+end_src
